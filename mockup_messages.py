"""
Mensagens mockadas longas para testes de streaming de tokens.
Cada mensagem tem aproximadamente 100-200 palavras para simular
respostas realistas de modelos de linguagem.
"""

MOCKUP_RESPONSES = [
    """The answer to your question is 42, which according to Douglas Adams' "The Hitchhiker's Guide to the Galaxy" is the ultimate answer to life, the universe, and everything. This number was computed by a massive supercomputer called Deep Thought over a period of 7.5 million years. However, the irony is that while we have the answer, the actual question remains unknown. Deep Thought suggested that an even greater computer would need to be built to figure out what the question actually was. This computer turned out to be Earth itself, which was unfortunately destroyed just five minutes before it would have completed its 10-million-year program. The philosophical implications of this are profound: sometimes having an answer without understanding the question is meaningless. In programming and life alike, we often focus on finding solutions before fully understanding the problems we're trying to solve. The number 42 has since become a cultural icon in tech circles, appearing as Easter eggs in various software products and serving as a reminder that even the most complex questions might have surprisingly simple, if initially confusing, answers.""",

    """Python is a versatile and powerful programming language that has become one of the most popular choices for developers worldwide. Created by Guido van Rossum and first released in 1991, Python was designed with code readability as a primary goal, using significant whitespace and a clean, intuitive syntax. The language supports multiple programming paradigms, including procedural, object-oriented, and functional programming styles. Python's extensive standard library, often described as coming with "batteries included," provides modules for everything from file I/O and networking to regular expressions and data serialization. The Python Package Index (PyPI) hosts hundreds of thousands of third-party packages, enabling developers to quickly add functionality for web development, data science, machine learning, automation, and more. Python's dynamic typing and interpreted nature make it excellent for rapid prototyping and scripting, while tools like type hints and static analyzers help maintain code quality in larger projects. The language has particularly thrived in data science and artificial intelligence, with libraries like NumPy, Pandas, TensorFlow, and PyTorch becoming industry standards.""",

    """Machine learning is a transformative branch of artificial intelligence that enables computer systems to learn and improve from experience without being explicitly programmed for every specific task. The field encompasses several distinct approaches: supervised learning, where models are trained on labeled data to make predictions; unsupervised learning, which discovers hidden patterns in unlabeled data; and reinforcement learning, where agents learn optimal behaviors through trial and error in an environment. Deep learning, a subset of machine learning using neural networks with many layers, has achieved breakthrough results in image recognition, natural language processing, and game playing. The training process involves feeding large datasets through algorithms that adjust internal parameters to minimize prediction errors, a process called optimization. Key concepts include feature engineering, model selection, hyperparameter tuning, and cross-validation to prevent overfitting. Machine learning applications now permeate daily life, from recommendation systems on streaming platforms to fraud detection in banking, medical diagnosis assistance, autonomous vehicles, and virtual assistants. The field continues to evolve rapidly, with new architectures and techniques emerging regularly, pushing the boundaries of what machines can learn to do.""",

    """The quick brown fox jumps over the lazy dog is a pangram, a sentence that contains every letter of the English alphabet at least once. Pangrams have been used for centuries to test typewriters, keyboards, fonts, and handwriting skills. This particular pangram gained popularity in the late 19th century and has become the most famous example in English. The sentence contains exactly 35 letters and uses each of the 26 letters at least once, making it relatively efficient while still forming a coherent, memorable phrase. Typography designers frequently use pangrams to showcase how different characters appear in a given typeface, ensuring that all letters are properly designed and spaced. Other notable pangrams include "Pack my box with five dozen liquor jugs" with only 32 letters, and "Sphinx of black quartz, judge my vow" with 29 letters. Creating short pangrams is actually quite challenging because the letters J, X, Q, and Z appear infrequently in English. The study of pangrams connects to cryptography, linguistics, and information theory, demonstrating how language structure influences text composition and pattern recognition.""",

    """WebSockets represent a significant advancement in web communication technology, providing full-duplex, bidirectional communication channels over a single, long-lived TCP connection. Unlike traditional HTTP requests, which follow a request-response pattern and require establishing new connections for each exchange, WebSockets maintain a persistent connection that allows both the server and client to send messages independently at any time. The protocol begins with an HTTP handshake that upgrades the connection to the WebSocket protocol, after which data frames can flow freely in both directions with minimal overhead. This makes WebSockets ideal for real-time applications such as chat systems, live sports updates, collaborative editing tools, multiplayer games, and financial trading platforms where low latency is crucial. The WebSocket API is straightforward to use in JavaScript, with events for connection open, message received, errors, and connection close. Server-side implementations exist for virtually every programming language and framework. While WebSockets excel at real-time communication, developers should consider alternatives like Server-Sent Events for unidirectional server-to-client streaming, or HTTP/2 and HTTP/3 for scenarios where the overhead of maintaining connections outweighs the benefits of persistent connections.""",

    """Asynchronous programming has revolutionized how developers write concurrent code, allowing programs to handle multiple operations efficiently without blocking execution. In Python, the async/await syntax introduced in Python 3.5 provides an elegant way to write asynchronous code that remains readable and maintainable. The asyncio library serves as the foundation for Python's async ecosystem, providing an event loop that manages and schedules coroutines, which are special functions that can be paused and resumed. When a coroutine awaits an I/O operation like a network request or file read, the event loop can execute other tasks instead of blocking, dramatically improving throughput for I/O-bound applications. Key concepts include coroutines defined with async def, the await keyword for suspending execution, Tasks for concurrent execution, and Futures for representing eventual results. Libraries like aiohttp, asyncpg, and aiofiles provide async-compatible implementations for HTTP requests, PostgreSQL queries, and file operations respectively. Understanding the difference between concurrency and parallelism is crucial: async programming achieves concurrency through cooperative multitasking on a single thread, while true parallelism requires multiple processes or threads for CPU-bound tasks.""",

    """The best way to predict the future is to create it, a philosophy embraced by successful innovators throughout history. This mindset emphasizes proactive action over passive waiting, encouraging individuals and organizations to shape their destinies rather than merely react to circumstances. In software development, this principle manifests in iterative approaches: start with a minimum viable product, gather feedback quickly, and continuously improve based on real-world usage. The Agile methodology embodies this philosophy, favoring working software over comprehensive documentation and responding to change over following a rigid plan. Successful startups often exemplify this approach, pivoting rapidly based on market feedback while maintaining a clear vision. The key is finding the balance between strategic planning and adaptable execution. Analysis paralysis, where excessive planning prevents action, is just as harmful as reckless implementation without forethought. Great products emerge from cycles of building, measuring, and learning. User feedback is invaluable, but true innovation sometimes means creating products people don't yet know they need. Steve Jobs famously noted that customers can't always articulate their desires for things that don't yet exist. Visionary creation requires both understanding current needs and imagining future possibilities.""",

    """Code is like humor: when you have to explain it, it's usually not very good. This programming wisdom emphasizes the importance of writing self-documenting, clear, and intuitive code. Good code should reveal its intent through meaningful variable names, logical structure, and appropriate abstractions. When another developer, or your future self, reads the code, the purpose and mechanism should be apparent without extensive comments or documentation. This doesn't mean comments are unnecessary, but they should explain why something is done, not what is being done, as the code itself should make the what obvious. Clean code principles advocate for small, focused functions that do one thing well, descriptive naming conventions, and consistent formatting. Code reviews become more productive when reviewers can quickly understand the changes without lengthy explanations. Refactoring plays a crucial role in maintaining code clarity: as understanding of a problem deepens, the code should evolve to reflect that understanding. Technical debt accumulates when clarity is sacrificed for speed, leading to codebases that become increasingly difficult to maintain and extend. Investing in code quality pays dividends in reduced bugs, easier onboarding of new team members, and faster feature development over time.""",

    """First, solve the problem, then write the code. This fundamental principle of software engineering emphasizes the critical importance of understanding and planning before implementation. Many developers fall into the trap of immediately starting to code when faced with a challenge, only to realize later that they've solved the wrong problem or created an unnecessarily complex solution. Effective problem-solving begins with clearly defining the problem: what exactly needs to be accomplished, what are the constraints, what edge cases exist, and what does success look like? Breaking down complex problems into smaller, manageable components makes them easier to tackle and test. Pseudocode and diagrams can help visualize solutions before committing to specific implementations. This approach also facilitates better communication with stakeholders and team members, ensuring everyone shares the same understanding of the goals. Design patterns and architectural decisions should be considered during this planning phase, as changing fundamental structure becomes increasingly expensive as a project progresses. However, avoid over-engineering: the goal is to find the simplest solution that adequately addresses the problem. Sometimes the best code is no code at all, achieved by reframing the problem or leveraging existing solutions.""",

    """Simplicity is the soul of efficiency, a principle that applies across all domains of software development and system design. Simple solutions are easier to understand, test, maintain, and scale. They have fewer potential points of failure and are more adaptable to changing requirements. Yet achieving simplicity is paradoxically difficult; it requires deep understanding of both the problem domain and the available tools. As Einstein reportedly said, everything should be made as simple as possible, but not simpler. In coding, this means avoiding unnecessary abstractions, preferring composition over inheritance, writing functions that do one thing well, and choosing clarity over cleverness. The KISS principle (Keep It Simple, Stupid) and YAGNI (You Aren't Gonna Need It) guide developers away from premature optimization and speculative features. Simple architectures scale better because they're easier to reason about and modify. When performance becomes an issue, simple code is easier to profile and optimize than complex code. The Unix philosophy of small, composable tools exemplifies this approach: simple programs that do one thing well can be combined to accomplish complex tasks. Technical leadership often involves pushing back against unnecessary complexity, asking whether simpler alternatives exist for proposed solutions.""",
]
